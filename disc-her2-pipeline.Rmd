---
title: "METABRIC Discovery Her2 Analysis"
author: "Christopher Conley, Pei Wang, Umut Ozbek, Jie Peng"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{METABRIC Discovery Her2 Analysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo = FALSE}
library(knitr)
opts_chunk$set(message=F, warning=F)
```

This document highlights the full network analysis pipeline of spaceMap applied to Her2 breast cancer samples. There are three major sections, namely (i) model tuning with cross validation, (ii) comparisons of CV.Vote and Boot.Vote ensemble networks, (iii) and network analysis efforts. Model tuning is an iterative process of arriving at the final tuning parameters, which  we detail with various diagnostic tools. 

## CV Vote Model Tuning 

The following function helps consolidate the diagnostic information for different iterations of CV.

```{r}
source("dxCV.R")
```

### Tuning iteration 1

We tuned SPACE on the mRNA data to narrow the neighborhood of `lam1`. Run the tuning diagnostics.

```{r}
dx1 <- dxspace(file = "~/scratch-data/neta-metabric/disc-cv-vote/her2/01/her2-01.rda", F)
```

We find a fairly stable CV-score curve in the upper-left corner that appears to be increasing to the left of `lam1=60`, but will require further exploration in follow-up tuning iterations.  The average number of y--y edges
is about 5000 per training fold, which is not too high.

### Tuning iteration 2

We tuned SPACE jointly on (mRNA, DNA copy number alteration intervals) to see the effect on `lam1` when we include DNA features. 

```{r}
dx2 <- dxspace(file = "~/scratch-data/neta-metabric/disc-cv-vote/her2/02/her2-02.rda", F, c(0,0.5))
```


The upper-left plot shows a slightly less stable curve compared to strictly mRNA input. In this scenario, the CV-selected `lam1` is larger than before and the number of y--y edges is correspondingly smaller (see bottom-left plot). Also, we are reminded of the limited x--y edge power when fitting SPACE based on the bottom-right plot. 

### Tuning iteration 3

In this tuning iteration which involves spaceMap, we set the `lam1` parameter to be closer to that of iteration 2 in hopes that the y--y network leaves some degrees of freedom left over for learning x--y edges given the limited signal and limited sample size scenario. The initial selection of ranges for `lam2,lam3` was intended to sample across the model space as indicated by a broad range in the number of x--y edges.  The following plot shows the initial grid for `lam2, lam3`, where the upper-left block searches the space of fewer x-hubs with larger degree and the lower-right space searches the space of more x-hubs with relatively smaller degree. 

```{r}
i03 <- new.env()
load("~/scratch-data/neta-metabric/disc-cv-vote/her2/03/her2-03.rda", envir = i03)
tmap3 <- i03$tmap
plot(tmap3$lam2, tmap3$lam3, ylab = "lam3", xlab = "lam2", pch = 19)
```


Note the following plot shows the CV scores profile for each tuning penalty of spaceMap. Also the plot zooms in on those CV-scores in the top 50% of all CV-scores; this means that certain tuning penalty combinations may have no CV-score depicted if the scores are particularly poor. 

```{r}
dx3 <- dxsmap(file = "~/scratch-data/neta-metabric/disc-cv-vote/her2/03/her2-03.rda", T, c(0,0.5))
```

Above, it is clear that the CV-selected `lam1` agrees with the first tuning iteration when just mRNA was input to SPACE. In the next iteration of tuning spaceMap, we will need to explore smaller values of `lam1`. With respect to `lam2,lam3`, the CV-score profiles do not clarify a clear optimal value, even though these tuning parameters index models with wide ranging numbers on x--y edges. The following plot shows the effect of `lam2,lam3` on x--y edge number.  

```{r}
grid.arrange(dx3$v2[[4]],dx3$v3[[4]], ncol = 2)
```


These diagnostics on `lam2,lam3` suggest a broad range of models have been considered, especially those favoring sparse models with less than 5000 x--y eges; however, the model selected tuning parameters on the boundary of the grid, as seen below, where the number "3" denotes the CV-selected tuning parameters for the 3rd iteration. In the next tuning iteration, we will need to shift the tuning parameters `lam1,lam2` lower. 

```{r, echo=FALSE}
par(mfrow = c(1,2))
plot(tmap3$lam1, tmap3$lam2, ylab = "lam2", xlab = "lam1", 
     pch = 19)
points(i03$cvsmap$minTune$lam1, i03$cvsmap$minTune$lam2, pch = "3", cex = 2)

plot(tmap3$lam2, tmap3$lam3, ylab = "lam3", xlab = "lam2", 
     pch = 19)
points(i03$cvsmap$minTune$lam2, i03$cvsmap$minTune$lam3, pch = "3", cex = 2)
```

### Tuning iteration 4


The fourth iteration produces CV-score profiles suggesting we have found near optimal values for all three tuning parameters. However, `lam2` is still on the boundary because of the odd-shaped nature of the tuning grid. 

```{r}
dx4 <- dxsmap(file = "~/scratch-data/neta-metabric/disc-cv-vote/her2/04/her2-04.rda")
```

In the figure, below, we see that iteration 4 tuning grid (rectangles) was not lowered sufficiently for `lam2`; the  number "4" on the plot indicates the CV-selected tuning parameter. The reason for the rectangular patch-work tuning grid was to save computational time by not tuning models with extremely high x--y edges due to low-penalty combinations of `lam2,lam3`. Clearly, we need to lower the `lam2` parameter. 

```{r, echo=FALSE}
i04 <- new.env()
load("~/scratch-data/neta-metabric/disc-cv-vote/her2/04/her2-04.rda", envir = i04)
tmap4 <- i04$tmap

par(mfrow = c(1,2))
plot(tmap3$lam1, tmap3$lam2, ylab = "lam2", xlab = "lam1", 
     pch = 19, xlim = c(50,80), ylim = c(8,40))
points(tmap4$lam1, tmap4$lam2, pch = 22)
points(i03$cvsmap$minTune$lam1, i03$cvsmap$minTune$lam2, pch = "3", cex = 2)
points(i04$cvsmap$minTune$lam1, i04$cvsmap$minTune$lam2, pch = "4", cex = 2)


plot(tmap3$lam2, tmap3$lam3, ylab = "lam3", xlab = "lam2", 
     pch = 19, xlim = c(8,35))
points(tmap4$lam2, tmap4$lam3, pch = 22)
points(i03$cvsmap$minTune$lam2, i03$cvsmap$minTune$lam3, pch = "3", cex = 2)
points(i04$cvsmap$minTune$lam2, i04$cvsmap$minTune$lam3, pch = "4", cex = 2)
```

It would appear this is a step in the right direction since the best CV-score of iteration 4 (score: `r round(i04$cvsmap$logcvScore,3)`) is lower than iteration 3 (score: `r round(i03$cvsmap$logcvScore,3)`). 

### Tuning iteration 5

Inspecting iteration 5 (see "+" symbols on plot below), we check the boundary and see that none of the tuning parameters is on the boundary.  Further, the best CV-score of iteration 5 (score: `r round(i05$cvsmap$logcvScore,3)`) is lower than iteration 4 (score: `r round(i04$cvsmap$logcvScore,3)`). 

```{r, echo=FALSE}
i05 <- new.env()
load("~/scratch-data/neta-metabric/disc-cv-vote/her2/05/her2-05.rda", envir = i05)
tmap5 <- i05$tmap

par(mfrow = c(1,2))
plot(tmap3$lam1, tmap3$lam2, ylab = "lam2", xlab = "lam1", 
     pch = 19, xlim = c(50,80), ylim = c(8,40))
points(tmap4$lam1, tmap4$lam2, pch = 22)
points(tmap5$lam1, tmap5$lam2, pch = "+")
points(i03$cvsmap$minTune$lam1, i03$cvsmap$minTune$lam2, pch = "3", cex = 2)
points(i04$cvsmap$minTune$lam1, i04$cvsmap$minTune$lam2, pch = "4", cex = 2)
points(i05$cvsmap$minTune$lam1, i05$cvsmap$minTune$lam2, pch = "5", cex = 2)


plot(tmap3$lam2, tmap3$lam3, ylab = "lam3", xlab = "lam2", 
     pch = 19, xlim = c(8,35))
points(tmap4$lam2, tmap4$lam3, pch = 22)
points(tmap5$lam2, tmap5$lam3, pch = "+")
points(i03$cvsmap$minTune$lam2, i03$cvsmap$minTune$lam3, pch = "3", cex = 2)
points(i04$cvsmap$minTune$lam2, i04$cvsmap$minTune$lam3, pch = "4", cex = 2)
points(i05$cvsmap$minTune$lam2, i05$cvsmap$minTune$lam3, pch = "5", cex = 2)
```

Looking at the CV-profiles (zoomin in on top 10% of scores), we believe we have found a stopping point.   

```{r}
dx5 <- dxsmap(file = "~/scratch-data/neta-metabric/disc-cv-vote/her2/05/her2-05.rda", T, c(0,.1))
```


The drop in edge count from the training folds to the CV.Vote model and the Boot.Vote model are indications of model instability. The following plot shows
we see more stability in the y--y edges than the x-y edge for the CV-vote model. It is somewhat troubling to see the large drop in model size for the the Boot.Vote model (B = 250).

```{r}
bv <- readRDS(file.path("~/scratch-data/neta-metabric/disc-boot-vote/her2/01/","her2-boot-vote-01.rds"))
dbv <- data.frame(xy = nonZeroWhole(bv$bv$xy,0.0),
                  yy = nonZeroUpper(bv$bv$yy,0.0),
                  type = "Boot.Vote")
dx5$gcvdrop + geom_point(data = dbv, size  = 2)
```

## Network Analysis on Boot.Vote

Read in the probe and CNA feature information stored in the ExpressionSet.

```{r}
library(Biobase)
filterdir <- "~/scratch-data/neta-metabric/disc-filtered/"
yinfo <- pData(featureData(readRDS(file = file.path(filterdir,"disc-mrna-eset-nostd-union-dropout-std-Her2.rds"))))
xinfo <- pData(featureData(readRDS(file = file.path(filterdir,"disc-cna-eset-nostd-union-dropout-multi-std-Her2.rds"))))
yinfo$start <- as.integer(yinfo$start)
yinfo$end <- as.integer(yinfo$end)
xinfo$start <- as.integer(xinfo$start)
xinfo$end <- as.integer(xinfo$end)
```

### Collapse probes to gene level

For the network analysis, we decided to collapse probe information down onto the gene-level. For example, if two probes map to the same locus, we take the union of their edges to form a single node. First, import and label fetures of the CV.Vote network. 

```{r}
#label the adjacency matrix 
#net <- i05$cvsmap$cvVote[c("yy","xy")]
net <- bv$bv
rownames(net$xy) <- xinfo$id; colnames(net$xy) <- yinfo$id;
rownames(net$yy) <- yinfo$id; colnames(net$yy) <- yinfo$id;
# bdeg <- bv$bdeg
# colnames(bdeg$xy) <- xinfo$id; colnames(bdeg$yy) <- yinfo$id; 
```

The following code merges probes onto the gene level. 

```{r}
egtab <- table(yinfo$EntrezReannotated)
eg2probeid <- lapply(names(egtab), function(eg) {
  yinfo$id[yinfo$EntrezReannotated %in% eg]  
})
#take union of edges between probes with same entrez gene id
meg <- eg2probeid[sapply(eg2probeid, length) > 1]
for(m in meg) { 
  uyedge <- apply(X = net$yy[m,], MARGIN = 2, FUN = max)
  uxedge <- apply(X = net$xy[,m], MARGIN = 1, FUN = max)
  net$yy[m[1],] <- uyedge
  net$xy[,m[1]] <- uxedge
}
#drop secondary listing of probes
secprobes <- unlist(sapply(meg, function(m) m[2:length(m)]))
keepers <- setdiff(rownames(net$yy), secprobes)
net$yy <- net$yy[keepers,keepers]
net$xy <- net$xy[,keepers]
#adjust order of yinfo
yinfo <- yinfo[match(keepers,yinfo$id),]
#bdeg$yy <- bdeg$yy[,keepers]
```

Next we replace the probe ID with the Entrez gene id. 

```{r}
probe2eg <- yinfo[,c("id", "EntrezReannotated")]
#all duplicates should be missing values now. 
eg <- probe2eg$EntrezReannotated
stopifnot(all(is.na(eg[which(duplicated(eg))])))
#replace ID with entrez gene
yinfo$probeid <- yinfo$id
yinfo$id <- ifelse(is.na(eg), yinfo$id, eg)
stopifnot(!anyDuplicated(yinfo$id))
```

Update the feature name labels of the network after merging the probes to the gene level. 

```{r}
rownames(net$xy) <- xinfo$id; colnames(net$xy) <- yinfo$id;
rownames(net$yy) <- yinfo$id; colnames(net$yy) <- yinfo$id;
#colnames(bdeg$xy) <- xinfo$id; colnames(bdeg$yy) <- yinfo$id; 
```

Now there are `r length(secprobes)` mRNA feature nodes lost from merging probes, leaving `r length(keepers)` mRNA gene nodes. Import the network to cytoscape. 

```{r}
library(spacemap)
ig <- spacemap::adj2igraph(yy = net$yy, xy = net$xy, yinfo = yinfo, xinfo = xinfo)
```

### Hub analysis

```{r}
ig <- rankHub(ig = ig, level = "y")
ig <- rankHub(ig = ig, level = "x")
```

```{r}
library(IRanges)
ig <- cisTrans(ig = ig, level = "x-y", cw = 2e6)
xhubs <- reportHubs(ig, top = 10, level = "x")
xhubs
```

```{r}
yhubs <- reportHubs(ig, top = 10, level = "y")
yhubs
```

```{r}
library(igraph)
mods <- cluster_edge_betweenness(ig)
```

### GO annotation

```{r}
rnaset <- readRDS(file = file.path(filterdir,"disc-mrna-eset-nostd-union-dropout-std-Her2.rds"))
rna_entrez_ids <- pData(featureData(rnaset))[,"EntrezReannotated"]
sum(is.na(rna_entrez_ids))
library(IRanges)
library(org.Hs.eg.db)
hs_feature_list <- function(db, eg) { 
  mk <- mappedkeys(db)
  xx <- as.list(db[eg[eg %in% mk]])
}
leg2go <- hs_feature_list(db = org.Hs.egGO, eg = rna_entrez_ids)
```


```{r}
library(foreach)
leg2go_filtered <- foreach(got = leg2go, eg = names(leg2go)) %do% { 
  bp_domain <- sapply(got, function(x) x[["Ontology"]]) == "BP"
  #bp_domain <- TRUE
  not_nd_domain <- sapply(got, function(x) x[["Evidence"]]) != "ND"
  bp_got <- got[bp_domain & not_nd_domain]
  sapply(bp_got, function(x) x[["GOID"]]) 
}
names(leg2go_filtered) <- names(leg2go)
leg2go_filtered <- leg2go_filtered[sapply(leg2go_filtered, length) != 0]
```

```{r}
suppressPackageStartupMessages(library(topGO))
go2eg <- inverseList(leg2go_filtered)
#remove duplicate entrez genes
go2eg <- lapply(go2eg, function(x) x[!duplicated(x)])
#saveRDS(go2eg, file = "~/repos/neta-bccptac/data/no-len-trim-rna-go-bp-to-entrez-gene-list.rds")
gosize <- sapply(go2eg, length)
go2eg <- go2eg[ gosize >= 15 & gosize <= 300]
#number of go terms satisfying conditions
length(go2eg)
#assure each go term has a list of non-duplicate ids
stopifnot(all(sapply(go2eg, anyDuplicated) == 0))
saveRDS(go2eg, file = file.path(filterdir, "her2-go-bp-to-entrez-gene-list.rds"))
```

```{r}
library(AnnotationDbi)
#human readable 
process_alias <- Term(names(go2eg))
```

```{r}
hgp <- xHubEnrich(ig = ig, go2eg = go2eg)
hgp2 <- hgp[hgp$neighbor_percentage > .30,]
hgp2
```

### Module analysis

```{r}
outmod <- modEnrich(ig = ig, mods = mods, levels = "y", go2eg = go2eg, process_alias = process_alias, prefix = "R")
```



```{r}
outmod$etab
```

## Save results

```{r}
filename <- file.path(filterdir, "her2-boot-vote-01.graphml")
#delete nodes without edges from the graph object
vis <- delete_vertices(graph = outmod$ig, v = V(outmod$ig)[igraph::degree(outmod$ig) == 0])
igraph::write_graph(graph = vis, file = filename, format = "graphml")
save.image(file = file.path(filterdir, "her2-full-analysis.rda"))
```


